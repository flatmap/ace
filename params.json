{"name":"Ace","tagline":"","body":"# Anorm for Cypher Embedded!\r\n\r\nThe [play!](http://www.playframework.org/) framework includes a simple data access layer called [Anorm](http://www.playframework.org/documentation/2.0.4/ScalaAnorm). It uses plain SQL to interact with the database and provides an API to parse and transform the resulting datasets.\r\nSome libraries exist to transfer this concept to the world of [Neo4j](http://www.neo4j.org/). The [Neo4j Scala wrapper](https://github.com/FaKod/neo4j-scala/) has introduced basic Cypher query support and [AnormCypher](http://anormcypher.org/) provides a Anorm-like API purely for REST.\r\n\r\nHowever, if you want to use Neo4j embedded in your applications you will be in need of another library. **Ace** (i.e. **A**norm for **C**ypher **E**mbedded) closes this gap and provides a data access layer that uses plain Cypher to interact with the database. Ace (much like AnormCypher) is modeled after Anorm for play! and it's API will look extremly similar.\r\nIf you have worked with Anorm before, you will find Ace very easy to understand and work with.\r\n\r\n## Executing Cypher queries\r\n\r\nTo start you need to learn how to execute simple Cypher queries.\r\n\r\nFirst, import `org.ace._`, and then simply use the `Cypher` object to create queries. You need to provide an implicit `GraphDatabaseService` to run a query:\r\n\r\n```scala\r\nimport org.ace._\r\n\r\nNeo4j.withTx { implicit service =>\r\n  val result: Boolean = Cypher(\"START n=node(0) RETURN n\").execute()    \r\n} \r\n```\r\n\r\nThe `execute()` method returns a boolean value indicating whether the execution was successful.\r\n\r\nTo execute an update, you can use `executeUpdate()`, which returns a 5-tuple containing:\r\n 1. The number of nodes created.\r\n 2. The number of relationships created.\r\n 3. The number of properties set.\r\n 4. The number of deleted nodes.\r\n 5. The number of deleted relationships.\r\n\r\n```scala\r\nval (nodesCreated, relsCreated, propsSet, nodesDeleted, relsDeleted) =\r\n  Cypher(\"START n=node(0) MATCH n-[r]-() DELETE n, r\").executeUpdate()\r\n```\r\n\r\nSince Scala supports multi-line strings, feel free to use them for complex Cypher statements:\r\n\r\n```scala\r\nval cypherQuery = Cypher(\r\n  \"\"\"\r\n    START n=node(0)\r\n    MATCH (n)--(x)\r\n    RETURN x\r\n  \"\"\"\r\n)\r\n```\r\n\r\nCypher supports querying with parameters. If your Cypher query needs dynamic parameters, you can assign them as follows:\r\n\r\n```scala\r\nCypher(\r\n  \"\"\"\r\n    START n=node(0,1,2)\r\n    RETURN n\r\n    SKIP {s}\r\n    LIMIT {l}\r\n  \"\"\"\r\n).on(\"s\" -> 1, \"l\" -> 1)\r\n```\r\n\r\n## Retrieving data using the Stream API\r\n\r\nThe first way to access the results of a select query is to use the Stream API.\r\n\r\nWhen you call `apply()` on any Cypher statement, you will receive a `Stream` of `Row` instances, where each row can be seen as a dictionary:\r\n\r\n```scala\r\n// Create a Cypher query\r\nval selectQuery = Cypher(\"START n=node(0) RETURN n.name, n.value\")\r\n \r\n// Transform the resulting Stream[Row] to a List[(String,String)]\r\nval selection = selectQuery().map(row => \r\n  row[String](\"n.name\") -> row[String](\"n.value\")\r\n).toList\r\n```\r\n\r\nIn the following example we will count the number of connected nodes from the start node, so the result set will be a single row with a single column:\r\n\r\n```scala\r\n// First retrieve the first row\r\nval firstRow = Cypher(\"START n=node(2) MATCH (n)-->(x) RETURN count(x) AS c\").apply().head\r\n \r\n// Next get the content of the 'c' column as Long\r\nval nodeCount = firstRow[Long](\"c\")\r\n```\r\n\r\n## Using Pattern Matching\r\n\r\nYou can also use Pattern Matching to match and extract the `Row` content. In this case the column name doesn’t matter. Only the order and the type of the parameters is used to match.\r\n\r\nThe following example transforms each row to the correct Scala type:\r\n\r\n```scala\r\ncase class SmallCountry(name:String) \r\ncase class BigCountry(name:String) \r\ncase class France\r\n \r\nval countries = Cypher(\"START n=node(*) WHERE n.type! = 'Country' RETURN n.name as name, n.population as pop\")().collect {\r\n  case Row(\"France\", _) => France()\r\n  case Row(name:String, pop:Int) if(pop > 1000000) => BigCountry(name)\r\n  case Row(name:String, _) => SmallCountry(name)      \r\n}\r\n```\r\n\r\nNote that since `collect(…)` ignores the cases where the partial function isn’t defined, it allows your code to safely ignore rows that you don’t expect.\r\n\r\n## Dealing with Nullable columns\r\n\r\nIf a column can contain `Null` values in the database schema, you need to manipulate it as an `Option` type.\r\n\r\nFor example, the `indepYear` of the `Country` table is nullable, so you need to match it as `Option[Int]`:\r\n\r\n```scala\r\nCypher(\"START n=node(*) WHERE n.type! = 'Country' RETURN n.name AS name, n.indepYear? AS year\")().collect {\r\n  case Row(name:String, Some(year:Int)) => name -> year\r\n}\r\n```\r\n\r\nIf you try to match this column as `Int` it won’t be able to parse `Null` values. Suppose you try to retrieve the column content as `Int` directly from the dictionary:\r\n\r\n```scala\r\nCypher(\"START n=node(*) WHERE n.type! = 'Country' RETURN n.name AS name, n.indepYear? AS year\")().map { row =>\r\n  row[String](\"name\") -> row[Int](\"year\")\r\n}\r\n```\r\n\r\nThis will produce an `UnexpectedNullableFound(year)` exception if it encounters a null value, so you need to map it properly to an `Option[Int]`, as:\r\n\r\n```scala\r\nCypher(\"START n=node(*) WHERE n.type! = 'Country' RETURN n.name AS name, n.indepYear? AS year\")().map { row =>\r\n  row[String](\"name\") -> row[Option[Int]](\"year\")\r\n}\r\n```\r\n\r\nThis is also true for the parser API, as we will see next.\r\n\r\n## Using the Parser API\r\n\r\nYou can use the parser API to create generic and reusable parsers that can parse the result of any select query.\r\n\r\n> **Note:** This is really useful, since most queries in a web application will return similar data sets. For example, if you have defined a parser able to parse a `Country` from a result set, and another `Language` parser, you can then easily compose them to parse both Country and Language from a join query.\r\n>\r\n> First you need to `import org.ace.CypherParser._`\r\n\r\n### Getting a single result\r\n\r\nFirst you need a `RowParser`, i.e. a parser able to parse one row to a Scala value. For example we can define a parser to transform a single column result set row, to a Scala `Long`:\r\n\r\n```scala\r\nval rowParser = scalar[Long]\r\n```\r\n\r\nThen we have to transform it into a `ResultSetParser`. Here we will create a parser that parse a single row:\r\n\r\n```scala\r\nval rsParser = scalar[Long].single\r\n```\r\n\r\nSo this parser will parse a result set to return a `Long`. It is useful to parse to result produced by a simple Cypher `COUNT` query:\r\n\r\n```scala\r\nval count: Long = Cypher(\"START n=node(*) return COUNT(n)\").as(scalar[Long].single)\r\n```\r\n\r\n### Getting a single optional result\r\n\r\nLet's say you want to retrieve a value from a query that might return null. We'll use the singleOpt parser:\r\n\r\n```scala\r\nval countryId: Option[Long] = Cypher(\"START n=node(*) WHERE n.type! = 'Country' AND n.country = 'France' RETURN ID(n)\").as(scalar[Long].singleOpt)\r\n```\r\n\r\n## Handling Neo4j types\r\n\r\nThe following parsers will retrieve Neo4j nodes and relationships from a query:\r\n\r\n```scala\r\nval node: org.neo4j.graphdb.Node = Cypher(\"START n=node(0) RETURN n\").as(node(\"n\").single)\r\nval rels: org.neo4j.graphdb.Relationship = Cypher(\"START n=node(0) MATCH n-[r]->() RETURN r\").as(relationship(\"r\") *)\r\n```\r\n\r\nIf you need to retrieve Cypher paths, you can use the `path` parser. It will result in a `Seq[org.neo4j.graphdb.PropertyContainer]` containing all nodes and relationships along the given path. These will usually emerge in alternate order.\r\n\r\n```scala\r\nval path: Seq[org.neo4j.graphdb.PropertyContainer] = Cypher(\"START n=node(0) MATCH p=n-[r]-m RETURN p\").as(path(\"p\") *)\r\n```\r\n\r\n# References\r\n\r\n * [Anorm](http://www.playframework.org/documentation/2.0.4/ScalaAnorm) - simple SQL data access\r\n * [AnormCypher](http://anormcypher.org/) - a Neo4j library purely for REST\r\n * [Play!](http://www.playframework.org/) - a framework for web applications with Java & Scala\r\n * [Neo4j](http://www.neo4j.org/) - an open-source, high-performance, enterprise-grade NOSQL graph database\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}